> 创建者：郭永峰
> 创建时间：2019-8-16
> 修改者：姚磊
> 修改时间：2019-10-17


<a name="Lph1c"></a>
## 模板级扩展
根据模板生成的页面，不满足当前需求时，我们可以通过增加扩展脚本，在扩展脚本中实现特定交互（例如字段的联动、修改表格数据、动态控制字段的显隐）。扩展脚本是放在business文件夹中。business文件夹根据子产品划分，因此在business下建立自己子产品编码值文件夹，并将所有扩展脚本放置里面。<br />

<a name="QXHLq"></a>
### 1 命名规则
模板扩展文件名字是有子产品编码（配置cSubId，如：EMM）和当前的单据编码billNo（配置cBillNo，如：emm_pcdaily_list）组成。<br />**eg:** EMM_emm_pcdaily_list_VM.Extend.js

![image.png](http://design.yonyoucloud.com/static/yuque/0/2019/png/271337/1571138096906-64c62d01-5000-4843-9bc2-39fa3949ffcd.png#align=left&display=inline&height=104&name=image.png&originHeight=208&originWidth=836&search=&size=37857&status=done&width=418)

<a name="qd0e5"></a>
### 2 加载流程和逻辑
<a name="XyyqP"></a>
#### 2.1 扩展脚本路径拼接
Node端拿到Java传过来的标准协议后，做了如下转换，新增了三个字段传到客户端，如下：<br />

```javascript
//viewmeta.vmName = viewmeta.cSubId + '_' + viewmeta.cBillNo + '_' + "VM"
viewmeta.vmName = _getVmName(viewmeta);

//viewmeta.extendFileName = viewmeta.vmName + '.Extend.js'
viewmeta.extendFileName = _getExtendVmFileName(viewmeta, extendName);

//viewmeta.extendVmName = viewmeta.vmName + '_Extend'
viewmeta.extendVmName = _getExtendVmName(viewmeta, extendName);

......

const _getVmName = (obj) => {
    if (!obj) return;
    return obj.cSubId + '_' + obj.cBillNo + '_' + "VM"
}
```

| **字段说明** | **字段名称** | **值** | **备注** |
| :---: | :---: | :---: | :---: |
| 模板扩展脚本文件名称 | extendFileName | EMM_emm_pcdaily_list_VM.Extend.js |  |
| 模板扩展的VM名称 | extendVmName | EMM_emm_pcdaily_list_VM_Extend |  |
| 模板VM名称 | vmName | EMM_emm_pcdaily_list_VM |  |


<a name="mWNX1"></a>
#### 2.2 模型中加载扩展脚本
Node端自动生成的页面模型中会加载扩展脚本，如下：

```javascript
......

model.prototype.initData = function () {
  ......
  // 如：EMM/EMM_emm_pcdaily_list_VM.Extend.js
  var extendFile = '<%=subId%>/<%=extendFileName%>';
  cb.require([extendFile], function (extend){
    ......
  }, function(error){
    ......
  });
};

......
```


<a name="0h0Hq"></a>
### 3 使用方式
<a name="TxQqN"></a>
#### 3.1 新建扩展脚本
在business目录下以当前子产品编码为名称创建一个子目录，在子目录下新建一个扩展脚本，并初始化如下代码：

```javascript
cb.define(['common/common_VM.Extend.js'], function (common) {
	var EMM_emm_pcdaily_list_VM_Extend = {
		doAction: function (name, viewmodel) {
			if (this[name])
				this[name](viewmodel);
		},
		init: function (viewmodel) {
	
		}
	}
	try {
		module.exports = EMM_emm_pcdaily_list_VM_Extend;
	} catch (error) {}
	return EMM_emm_pcdaily_list_VM_Extend;
});
```

- define参数说明：
加载依赖的公共扩展脚本
- doAction：框架中加载扩展脚本的入口
- init：初始化整个扩展脚本

在扩展脚本中，可以获取页面控件层面的viewmodel，调用相关viewmodel的API实现具体的特定的交互。可以通过相关api 获取当前页面UI组件所对应的viewmodel对象， 通常扩展业务逻辑一般都写在init函数内。

<a name="SCCPN"></a>
#### 3.2 以省市参照联动扩展为例
新建一个文件名为EMM_emm_pcdaily_list_VM.Extend.js放到<project>/src/client/business/AA下，里面init函数内代码如下：
```javascript
init: function (viewmodel) {
    // 在城市参照弹出之前，获取省参照的value，通过setFilter将value存放到过滤条件中（在城市参照获取城市列表时，会通过getFilter()获取value，作为过滤参数传到服务端）
    viewmodel.get("bankcity").on('beforeBrowse', function (data) {
        var provinceValue;
        if(!viewmodel.get("bankprovince").getValue()){
            cb.utils.alert("请选择开户省");
            return false;
        }else{
          	provinceValue = viewmodel.get("bankprovince").getValue();
        }
        var condition = {
            "isRefreshData": true,
            "parentId":provinceValue,
            "province":provinceValue
        };
        this.setFilter(condition);
    });
    // 如果省参照的值有改变，就将城市参照的值清空
    viewmodel.get("bankprovince").on('afterValueChange', function (data) {
      	viewmodel.get("bankcity").setValue(null);
    });
}
```

- "bankcity"为城市选择参照的字段名称（excel表中对应的cFieldName）
- "bankprovince" 为省选择参照的字段名称，provinceValue为获取的省选择参照的id。
- 模版内所有字段名称可在 <project>/autogenerate/viewmodel/AA 下自动生成的对应的渲染模版js文件内找到
- "beforeBrowse"为城市选择参照，参照model弹出前的方法

<a name="TRkje"></a>
#### 3.3 线上用例
两种参照联动方式:

  - 卡片的参照联动 参考  立即体验-- 食品/医药/家装/珠宝 --- 首页---数据中心---存量查询  里面的门店和仓库为参照联动
  - table表格内参照联动 参考 立即体验 --家装 --- 首页 -- 定价中心 -- 调价单 -- 新增 -- 增行 里面的商品编码和商品sku编码为参照联动

<a name="T02Fv"></a>
#### 3.4 相关API参考文档
参考[数据模型相关API](https://www.yuque.com/gpgy5k/ucf/cx96ve)。

<a name="kRVCh"></a>
#### 3.5 抽取公共逻辑
一般会把通用的逻辑进行抽取放到common中。一般会在bussiness中建立一个common文件夹里面放一些公共逻辑。其他各业务节点可以先将公共脚本载入进行依赖，如下：

![image.png](http://design.yonyoucloud.com/static/yuque/0/2019/png/192681/1567684535675-02540895-7214-4da4-99c8-47c5743cf662.png#align=left&display=inline&height=266&name=image.png&originHeight=666&originWidth=1010&search=&size=55325&status=done&width=404)