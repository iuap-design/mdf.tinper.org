根据模板生成的页面，不满足当前需求时，我们可以通过增加扩展脚本，在扩展脚本中实现特定交互（例如字段的联动、修改表格数据、动态控制字段的显隐）。扩展脚本是放在business文件夹中。business文件夹根据领域划分，因此在business下建立自己领域code值文件夹，并将所有扩展脚本放置里面。

<a name="bBnph"></a>
## 命名规则
<a name="vLK7U"></a>
#### 模板扩展脚本
模板扩展文件名字是有领域编码（配置cSubId，如：bd）和当前的单据号billNo（配置cBillNo，如：org_center_card）组成。eg: xx_VM.Extend.js

![image.png](http://design.yonyoucloud.com/static/yuque/0/2019/png/192681/1567681983962-c0b9b09a-e7a2-4e76-b129-039564fc7e0d.png#align=left&display=inline&height=118&name=image.png&originHeight=294&originWidth=1006&search=&size=37002&status=done&width=402.4)
<a name="oW1bV"></a>
#### 查询区扩展脚本
查询区的扩展文件名是在excel中配置的。在excel中[pb_meta_filters]表中behaviorObject字段定义当前查询区扩展文件的路径。eg: emm/emm_emm_inspectstd_list_filterVM.Extend.js。查询区扩展脚本也放在领域Code文件夹下。<br />默认规范：'领域Code_'+'单据编号_'+'filterVM.Extend.js'。

** 注：** 查询区扩展脚本定义需加上领域Code文件夹路径。<br /> 

<a name="4WQQB"></a>
## 加载流程和逻辑说明

<a name="QzMjP"></a>
### Node 端扩展脚本路径拼接
Node端拿到Java传过来的标准协议后，做了如下转换，新增了三个字段传到客户端：

```javascript
//viewmeta.vmName = viewmeta.cSubId + '_' + viewmeta.cBillNo + '_' + "VM"
viewmeta.vmName = _getVmName(viewmeta);

//viewmeta.extendFileName = viewmeta.vmName + '.Extend.js'
viewmeta.extendFileName = _getExtendVmFileName(viewmeta, extendName);

//viewmeta.extendVmName = viewmeta.vmName + '_Extend'
viewmeta.extendVmName = _getExtendVmName(viewmeta, extendName);


....


const _getVmName = (obj) => {
    if (!obj) return;
    return obj.cSubId + '_' + obj.cBillNo + '_' + "VM"
}

```


| 字段说明 | 字段名称 | 值 | 备注 |
| --- | --- | --- | --- |
| 模板扩展脚本文件名称 | extendFileName | AA_aa_orgtree_VM.Extend.js |  |
| 模板扩展的vm名称 | extendVmName | AA_aa_orgtree_VM_Extend |  |
| 模板vm名称 | vmName | AA_aa_orgtree_VM |  |


<a name="Dcm53"></a>
### Node端自动生成的页面模型中加载扩展脚本

```javascript
.....

model.prototype.initData = function () {
  .....
  // 如：RM/RM_rm_retailvouch_VM_billing.Extend.js
  var extendFile = '<%=subId%>/<%=extendFileName%>';
  cb.require([extendFile], function (extend){
    ......
  }, function(error){
    .......
  });
};

...

```


<a name="aeVY7"></a>
## 使用方式
在扩展脚本中，可以获取页面控件层面的model,调用相关model的API实现具体的特定的交互。

```javascript
cb.define(['common/common_VM.Extend.js'], function (common) {
	var SB_billNolist_VM_Extend = {
		doAction: function (name, viewmodel) {
			if (this[name])
				this[name](viewmodel);
		},
		init: function (viewmodel) {
	
		},		

	}
	try {
		module.exports = SB_billNolist_VM_Extend;
	} catch (error) {

	}
	return SB_billNolist_VM_Extend;
});
```
具体示例可以参考[这里](https://www.yuque.com/gpgy5k/ucf/rfmm1s)<br />一般会把通用的逻辑进行抽取放到common中。一般会在bussiness中建立一个common文件夹里面放一些公共逻辑。其他各业务节点可以先将公共脚本载入进行依赖。

![image.png](http://design.yonyoucloud.com/static/yuque/0/2019/png/192681/1567684535675-02540895-7214-4da4-99c8-47c5743cf662.png#align=left&display=inline&height=266&name=image.png&originHeight=666&originWidth=1010&search=&size=55325&status=done&width=404)

<a name="wBzUG"></a>
## Web和mobile扩展脚本的差异化维护和引入方式


<a name="zuEVX"></a>
## 租户级扩展脚本的引入流程
租户管理员可以在自定义按钮菜单，进入配置自己的扩展脚本，这样就实现不同租户加载不同的扩展脚本。通过自定义按钮菜单配置的在java端返回的协议中会多个extscripturls字段，运行是会再加载extscripturls对应的扩展脚本。

extscripturls ：存放的是额外扩展文件的服务器地址，其类型可以是字符串、字符串数组。<br />eg:

```javascript
extscripturls.push('http://resources.yonyoucloud.com/packages/TestExternal.js');
```