<a name="P9kKn"></a>
# 参照扩展
当前版本参照不支持单独的扩展脚本，如果需要干预参照中的模型，可以在打开参照的父单据的扩展脚本中实现。
<a name="7dZJk"></a>
## 1 依托单据扩展实现参照逻辑
在单据的扩展脚本中通过ReferModel中缓存（Cache）的'vm'属性，获取弹出参照中的模型，拿到编程模型之后可按API提供的能力进行扩展编程。如下：
```javascript
// 获取卡片中弹出参照的模型
viewmodel.get('field1').getCache('vm').getTreeModel();
// 获取表格中弹出参照的模型
viewmodel.get('table1').getEditRowModel().get('column1').getCache('vm').getTreeModel();

// 获取卡片中弹出参照的模型
viewmodel.get('field1').getCache('vm').getGridModel();
// 获取表格中弹出参照的模型
viewmodel.get('table1').getEditRowModel().get('column1').getCache('vm').getGridModel();
```

<a name="iqvJy"></a>
## 2 参照中初始化的模型
参照中初始化的编程模型，被初始化的模型都可以通过上述方法获取。
```javascript
......
// 参照中模型初始化代码片段
var fields = {
    referInput: new cb.models.SimpleModel(),
    referButton: new cb.models.SimpleModel(),
    filter: new cb.models.SimpleModel(),
    reload: new cb.models.SimpleModel(),
    searchBox: new cb.models.SimpleModel(),
    tree: new cb.models.TreeModel({ 
        keyField: 'code', 
        titleField: 'name', 
        multiple: this.getParams().multiple 
    }),
    table: new cb.models.GridModel({
        showAggregates: false,
        multiple: this.getParams().multiple,
        dataSourceMode: 'remote',
        override: cb.rest.interMode === 'touch' ? false : true,
        pageInfo: { pageSize: pageSize, pageIndex: 1 }
    }),
    submit: new cb.models.SimpleModel(),
    cancel: new cb.models.SimpleModel(),
    switch: new cb.models.SimpleModel()
};
this.setData(fields);
......
```